<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Tips 4 Spring Devs on </title>
    <link>https://thehecklers.com/tags/tips-4-spring-devs/</link>
    <description>Recent content in Tips 4 Spring Devs on </description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-US</language>
    <lastBuildDate>Tue, 20 Jun 2017 20:27:09 -0600</lastBuildDate>
    
	<atom:link href="https://thehecklers.com/tags/tips-4-spring-devs/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>T4SD (Tips 4 Spring Devs): How to get Spring Boot REST endpoints to speak XML</title>
      <link>https://thehecklers.com/post/t4sd-tips-4-spring-devs-how-to-get-spring-boot-rest-endpoints-to-speak-xml/</link>
      <pubDate>Tue, 20 Jun 2017 20:27:09 -0600</pubDate>
      
      <guid>https://thehecklers.com/post/t4sd-tips-4-spring-devs-how-to-get-spring-boot-rest-endpoints-to-speak-xml/</guid>
      <description>Many of us use JSON almost exclusively now, which is generally a good thing. But what happens when you need to “speak XML” with your Spring Boot REST endpoints?
 XML support in Spring Boot’s REST endpoints is not enabled by default, but adding it isn’t difficult at all. Simply add the following dependency to your POM (or similar entry to your Gradle build file, if that’s the way you roll) and rebuild:</description>
    </item>
    
    <item>
      <title>T4SD (Tips 4 Spring Devs): Request header filtering in @RequestMapping</title>
      <link>https://thehecklers.com/post/t4sd-tips-4-spring-devs-request-header-filtering-in-requestmapping/</link>
      <pubDate>Thu, 08 Jun 2017 20:37:31 -0600</pubDate>
      
      <guid>https://thehecklers.com/post/t4sd-tips-4-spring-devs-request-header-filtering-in-requestmapping/</guid>
      <description>Just a quick tip for the Spring fans out there&amp;#8230;&amp;#8203;
 I was leading a workshop yesterday and this question arose: Is it possible to filter requests by header content using Spring’s various request mapping (@RequestMapping, @GetMapping, @PostMapping, et al) annotations? Not only is it possible, it’s easy, and the implementation is concise &amp;amp; clean! Let’s take a look.  The code Here is a simple example that filters based upon the content-type of the header:</description>
    </item>
    
    <item>
      <title>T4SD (Tips 4 Spring Devs): Exposing Query Methods in Spring Data REST</title>
      <link>https://thehecklers.com/post/t4sd-tips-4-spring-devs-exposing-query-methods-in-spring-data-rest/</link>
      <pubDate>Tue, 26 Jul 2016 15:46:25 -0600</pubDate>
      
      <guid>https://thehecklers.com/post/t4sd-tips-4-spring-devs-exposing-query-methods-in-spring-data-rest/</guid>
      <description>Spring Data REST takes an opinionated approach to exposing Spring Data repositories via REST endpoints, covering the 80-90% use case with a minimum of code and fuss. But did you know that it provides a no-lifting-required mechanism for exposing query methods you define on those repositories as well?
 Let’s say you create a method like this:
  Referencing that bit of functionality directly is simple, just append /search/&amp;lt;methodName&amp;gt; to the collection endpoint:</description>
    </item>
    
  </channel>
</rss>